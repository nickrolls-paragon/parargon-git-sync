"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixDataSourceReferencesInInputSource = exports.convertUserDefinedInputsToSerializedInputs = exports.convertSerializedInputsToUserDefinedInputs = exports.mapUserDefinedInputsWithTitle = exports.mapSourcesWithTitle = exports.getSourceKey = exports.getInputTypeForUI = void 0;
const utils_1 = require("../utils/utils");
const input_constants_1 = require("./input.constants");
const input_interface_1 = require("./input.interface");
const getInputTypeForUI = (input) => {
    return (0, utils_1.toSnakeCase)(input.title);
};
exports.getInputTypeForUI = getInputTypeForUI;
const getSourceKey = (source) => {
    return ('id' in source ? source.id : source.cacheKey);
};
exports.getSourceKey = getSourceKey;
const mapSourcesWithTitle = (inputSources) => {
    return (0, utils_1.indexBy)(exports.getInputTypeForUI, inputSources);
};
exports.mapSourcesWithTitle = mapSourcesWithTitle;
const mapUserDefinedInputsWithTitle = (inputs) => {
    const titleSet = new Set();
    return (0, utils_1.indexBy)((input) => {
        let title = (0, utils_1.toSnakeCase)(input.title);
        let count = 1;
        while (titleSet.has(title)) {
            title = `${input.title}_${count}`;
            count += 1;
        }
        titleSet.add(title);
        return title;
    }, inputs);
};
exports.mapUserDefinedInputsWithTitle = mapUserDefinedInputsWithTitle;
const isCustomFieldMappingInput = (input) => {
    return (input.type === input_interface_1.SidebarInputType.FieldMapper && !('sourceType' in input));
};
const convertSerializedInputsToUserDefinedInputs = (inputs, inputSources) => {
    const basicTypeToInputNameMap = (0, utils_1.mapValueToKeyInRecord)(input_constants_1.BASIC_INPUT_NAME_TO_INPUT_TYPE_MAP);
    const sourcesByKey = (0, utils_1.indexBy)(exports.getSourceKey, inputSources);
    return inputs
        .map((input) => {
        if (isCustomFieldMappingInput(input)) {
            const byoFieldMappingTestOptions = input.byoFieldMappingTestOptions ?? {
                objectTypes: [],
                integrationFields: [],
            };
            return {
                id: input.id,
                title: input.title,
                type: 'custom_field_mapping',
                objectName: input.dynamicObjectName ?? '',
                mockObjectTypes: byoFieldMappingTestOptions.objectTypes,
                mockIntegrationFields: byoFieldMappingTestOptions.integrationFields,
                tooltip: input.tooltip || '',
                required: input.required,
            };
        }
        if (basicTypeToInputNameMap[input.type]) {
            return {
                id: input.id,
                title: input.title,
                tooltip: input.tooltip || '',
                required: input.required,
                type: basicTypeToInputNameMap[input.type],
                ...(input.type === input_interface_1.SidebarInputType.CustomDropdown
                    ? {
                        key: input.key,
                        customDropdownOptions: input.customDropdownOptions,
                    }
                    : {}),
            };
        }
        const source = sourcesByKey[input['sourceType']];
        if (!source) {
            return undefined;
        }
        const userDefinedInput = {
            id: input.id,
            title: input.title,
            tooltip: input.tooltip || '',
            required: input.required,
            type: (0, exports.getInputTypeForUI)(source),
        };
        switch (input.type) {
            case input_interface_1.SidebarInputType.ComboInput:
                return {
                    ...userDefinedInput,
                    fieldMappings: input.savedFieldMappings,
                };
            case input_interface_1.SidebarInputType.DynamicComboInput:
                return {
                    ...userDefinedInput,
                    showRequiredFieldsByDefault: input.useDynamicFields,
                };
            case input_interface_1.SidebarInputType.FieldMapper:
                if (!input.useDynamicMapper) {
                    return {
                        ...userDefinedInput,
                        useDynamicMapper: false,
                        fieldMappings: input.savedFieldMappings,
                    };
                }
                return {
                    ...userDefinedInput,
                    useDynamicMapper: true,
                    dynamicObjectName: input.dynamicObjectName,
                    dynamicObjectOptions: input.dynamicObjectOptions,
                };
            default:
                return userDefinedInput;
        }
    })
        .filter((value) => Boolean(value));
};
exports.convertSerializedInputsToUserDefinedInputs = convertSerializedInputsToUserDefinedInputs;
const convertUserDefinedInputsToSerializedInputs = (inputs, inputSources) => {
    const titleToSourceMap = (0, exports.mapSourcesWithTitle)(inputSources);
    const uniqueIdSet = new Set();
    const serializedInputs = inputs.map((input) => {
        if (uniqueIdSet.has(input.id)) {
            throw new Error(`Input id must contain unique id key. Found duplicate input id (${input.id})`);
        }
        uniqueIdSet.add(input.id);
        if (input_constants_1.BASIC_INPUT_NAME_TO_INPUT_TYPE_MAP[input.type]) {
            return {
                id: input.id,
                title: input.title,
                tooltip: input.tooltip,
                required: input.required,
                type: input_constants_1.BASIC_INPUT_NAME_TO_INPUT_TYPE_MAP[input.type],
                ...(input.type === 'custom_dropdown'
                    ? {
                        customDropdownOptions: input.customDropdownOptions,
                        key: input.key,
                    }
                    : {}),
            };
        }
        if (input.type == 'custom_field_mapping') {
            return {
                id: input.id,
                title: input.title,
                tooltip: input.tooltip,
                required: input.required,
                type: input_interface_1.SidebarInputType.FieldMapper,
                sourceType: undefined,
                useDynamicMapper: true,
                dynamicObjectName: input.objectName,
                byoFieldMappingTestOptions: {
                    objectTypes: input.mockObjectTypes ?? [
                        {
                            label: 'Contacts',
                            value: 'contacts',
                        },
                        {
                            label: 'Leads',
                            value: 'leads',
                        },
                    ],
                    integrationFields: input.mockIntegrationFields ?? [
                        {
                            label: 'First Name',
                            value: 'first_name',
                        },
                        {
                            label: 'Last Name',
                            value: 'last_name',
                        },
                        {
                            label: 'Email',
                            value: 'email',
                        },
                    ],
                },
            };
        }
        const source = titleToSourceMap[input.type];
        if (!source) {
            throw new Error(`Invalid source type (${input.type}).`);
        }
        let baseSerializedInput = {
            id: input.id,
            title: input.title,
            tooltip: input.tooltip,
            required: input.required,
        };
        let serializedInput;
        switch (source.type) {
            case input_interface_1.DataSourceType.COMBO_INPUT:
                serializedInput = {
                    ...baseSerializedInput,
                    type: input_interface_1.SidebarInputType.ComboInput,
                    sourceType: (0, exports.getSourceKey)(source),
                    savedFieldMappings: input.fieldMappings,
                };
                break;
            case input_interface_1.DataSourceType.DYNAMIC_COMBO_INPUT:
                serializedInput = {
                    ...baseSerializedInput,
                    type: input_interface_1.SidebarInputType.DynamicComboInput,
                    sourceType: (0, exports.getSourceKey)(source),
                    useDynamicFields: input.showRequiredFieldsByDefault ?? true,
                };
                break;
            case input_interface_1.DataSourceType.FIELD_MAPPER:
                if (input.useDynamicMapper) {
                    serializedInput = {
                        ...baseSerializedInput,
                        type: input_interface_1.SidebarInputType.FieldMapper,
                        sourceType: (0, exports.getSourceKey)(source),
                        useDynamicMapper: true,
                        dynamicObjectName: input.dynamicObjectName,
                        dynamicObjectOptions: input.dynamicObjectOptions,
                    };
                }
                else {
                    serializedInput = {
                        ...baseSerializedInput,
                        type: input_interface_1.SidebarInputType.FieldMapper,
                        sourceType: (0, exports.getSourceKey)(source),
                        useDynamicMapper: false,
                        savedFieldMappings: input.fieldMappings || [],
                    };
                }
                break;
            default:
                serializedInput = {
                    ...baseSerializedInput,
                    type: input_constants_1.INPUT_NAME_TO_INPUT_TYPE_MAP[source.type],
                    sourceType: (0, exports.getSourceKey)(source),
                };
                break;
        }
        return serializedInput;
    });
    return serializedInputs;
};
exports.convertUserDefinedInputsToSerializedInputs = convertUserDefinedInputsToSerializedInputs;
const fixDataSourceReferencesInInputSource = (source, dependencies) => {
    if (!dependencies || !dependencies.inputs || !dependencies.sharedInputs) {
        return source;
    }
    let input = undefined;
    const sharedInput = dependencies.sharedInputs.find((input) => input.id === source.inputId);
    if (sharedInput) {
        source.fieldType = 'SHARED_WORKFLOW_SETTING';
        input = sharedInput;
    }
    else {
        source.fieldType = 'WORKFLOW_SETTING';
        input = dependencies.inputs.find((input) => input.id === source.inputId);
    }
    if (!input) {
        throw new Error(`Input with id ${source.inputId} not present in defined inputs.`);
    }
    const getSource = (input) => {
        const inputSource = (dependencies.inputSources ?? []).find((source) => (0, exports.getSourceKey)(source) === input['sourceType']);
        if (!inputSource) {
            throw new Error(`No input source found for input with id ${input.id}`);
        }
        return inputSource;
    };
    switch (input.type) {
        case input_interface_1.SidebarInputType.ComboInput: {
            const inputSource = getSource(input);
            const userDefinedPath = source.path?.[0];
            const paths = [];
            if (!userDefinedPath) {
                return {
                    type: source.type,
                    fieldType: source.fieldType,
                    inputId: source.inputId,
                    path: paths,
                };
            }
            if (userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.mainInputSource)) {
                paths.push('mainInput');
            }
            else if (userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.dependentInputSource)) {
                paths.push('dependentInput');
            }
            else if (inputSource.fieldSource &&
                userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.fieldSource)) {
                const restPaths = source.path.slice(1);
                paths.push('fieldMappings', ...restPaths);
            }
            return {
                type: source.type,
                fieldType: source.fieldType,
                inputId: source.inputId,
                path: paths,
            };
        }
        case input_interface_1.SidebarInputType.DynamicComboInput: {
            const inputSource = getSource(input);
            const userDefinedPath = source.path?.[0];
            const paths = [];
            if (!userDefinedPath) {
                return {
                    type: source.type,
                    fieldType: source.fieldType,
                    inputId: source.inputId,
                    path: paths,
                };
            }
            if (userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.mainInputSource)) {
                paths.push('mainInput');
            }
            else if (userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.dependentInputSource)) {
                paths.push('dependentInput');
            }
            else if (inputSource.variableInputSource &&
                userDefinedPath ===
                    (0, exports.getInputTypeForUI)(inputSource.variableInputSource)) {
                const restPaths = source.path.slice(1);
                paths.push('variableInput', ...restPaths);
            }
            return {
                type: source.type,
                fieldType: source.fieldType,
                inputId: source.inputId,
                path: paths,
            };
        }
        case input_interface_1.SidebarInputType.FieldMapper: {
            const inputSource = input.sourceType
                ? getSource(input)
                : undefined;
            const userDefinedPath = source.path?.[0];
            const paths = [];
            const isObjectPathForNativeFieldMapper = inputSource &&
                userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.recordSource);
            const isObjectPathForCustomFieldMapping = !inputSource && userDefinedPath === 'object';
            const isFieldPathForNativeFieldMapper = inputSource &&
                userDefinedPath === (0, exports.getInputTypeForUI)(inputSource.fieldSource);
            const isFieldPathForCustomFieldMapping = !inputSource && userDefinedPath === 'fields';
            if (isObjectPathForNativeFieldMapper ||
                isObjectPathForCustomFieldMapping) {
                paths.push('objectMapping');
            }
            else if (isFieldPathForNativeFieldMapper ||
                isFieldPathForCustomFieldMapping) {
                const restPaths = source.path.slice(1);
                paths.push('fieldMappings', ...restPaths);
            }
            return {
                type: source.type,
                fieldType: source.fieldType,
                inputId: source.inputId,
                path: paths,
            };
        }
        default:
            return {
                type: source.type,
                fieldType: source.fieldType,
                inputId: source.inputId,
                path: [],
            };
    }
};
exports.fixDataSourceReferencesInInputSource = fixDataSourceReferencesInInputSource;
//# sourceMappingURL=input.utils.js.map