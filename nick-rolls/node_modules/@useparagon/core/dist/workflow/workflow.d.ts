import { IContext } from '../execution';
import { UserDefinedInput } from '../inputs';
import { ICustomIntegration, IIntegration } from '../integration';
import { IPersona } from '../persona';
import { StateMachine } from '../stateMachine/stateMachine.interface';
import { IStep, Step } from '../steps';
import { ConditionalInput } from '../steps/library/conditional';
import { IConnectUser, IPermissionContext } from '../user';
import { IExecutableWorkflow, WorkflowDependencies } from './workflow.interface';
export declare abstract class Workflow<I extends IIntegration | ICustomIntegration, P extends IPersona = IPersona, InputResultMap extends Record<string, any> = Record<string, any>> implements IExecutableWorkflow<I> {
    id: string;
    steps: IStep[];
    private integrationType;
    abstract inputs: Record<string, UserDefinedInput<string>>;
    abstract name: string;
    abstract description: string;
    abstract defaultEnabled: boolean;
    abstract hidden: boolean;
    private events;
    private secrets;
    private sharedInputs;
    private inputSources;
    private customTriggers;
    private resources;
    private previousStateMachine?;
    private paginationSchemes;
    constructor(dependencies: WorkflowDependencies);
    abstract define(integration: I, context: IContext<InputResultMap>, user: IConnectUser<P>): Promise<StateMachine>;
    abstract definePermissions(user: IPermissionContext<P>): ConditionalInput | undefined;
    register(nameToStepMap: Record<string, Step>): Promise<StateMachine>;
    private attemptToFixStepReferences;
    private reset;
    setPreviousStateMachine(stateMachine: StateMachine): void;
}
