"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workflow = void 0;
const uuid_1 = require("uuid");
const inputs_1 = require("../inputs");
const stateMachine_utils_1 = require("../stateMachine/stateMachine.utils");
const steps_1 = require("../steps");
const integrationRequest_1 = require("../steps/library/integrationRequest");
const utils_1 = require("../utils");
const workflow_interface_1 = require("./workflow.interface");
class Workflow {
    id = workflow_interface_1.UNSET_WORKFLOW_ID;
    steps = [];
    integrationType;
    events = [];
    secrets;
    sharedInputs = [];
    inputSources = [];
    customTriggers = [];
    resources = [];
    previousStateMachine;
    paginationSchemes = [
        integrationRequest_1.REQUEST_PAGINATION_STRATEGY.Token,
    ];
    constructor(dependencies) {
        this.previousStateMachine = dependencies.previousStateMachine;
        this.events = dependencies.events;
        this.inputSources = dependencies.inputSources;
        this.sharedInputs = dependencies.sharedInputs;
        this.secrets = dependencies.secrets;
        this.integrationType = dependencies.integrationType;
        this.paginationSchemes = dependencies.paginationSchemes;
        this.customTriggers = dependencies.customTriggers;
        this.resources = dependencies.resources;
    }
    async register(nameToStepMap) {
        this.reset();
        nameToStepMap = this.attemptToFixStepReferences(nameToStepMap);
        const steps = Object.values(nameToStepMap)
            .map((step) => step.toObject())
            .map((step) => {
            this.steps.push(step);
            return step;
        });
        return (0, stateMachine_utils_1.workflowStepsToStateMachine)(steps);
    }
    attemptToFixStepReferences(nameToStepMap) {
        const previousStepMap = this.previousStateMachine
            ? this.previousStateMachine.stepMap
            : {};
        const previousSteps = Object.values(previousStepMap);
        const previousStepNameToStepIdMap = previousSteps.length
            ? (0, utils_1.mapValueToKeyInRecord)((0, steps_1.mapStepIdToVariableName)(previousSteps))
            : {};
        const previousTriggerStep = previousSteps.find(steps_1.isTrigger);
        const triggerStep = Object.entries(nameToStepMap).find(([_name, step]) => (0, steps_1.isTrigger)(step))?.[1];
        if (!triggerStep) {
            throw new Error('Trigger step not found.');
        }
        const idToStepMap = (0, utils_1.indexBy)('id', Object.values(nameToStepMap));
        const stepIdToNameMap = Object.fromEntries(Object.entries(nameToStepMap).map(([stepName, step]) => [
            step.id,
            stepName,
        ]));
        const getStepById = (stepId) => {
            if (!idToStepMap[stepId]) {
                throw new Error('Please add all steps in register method.');
            }
            return idToStepMap[stepId];
        };
        const inputs = (0, inputs_1.convertUserDefinedInputsToSerializedInputs)(Object.values(this.inputs), this.inputSources);
        const stepTempIdToActualIdStore = {};
        const traverseStep = (step, tempIdToStepIdMap) => {
            const temporaryStepId = step.id;
            const previousStep = previousStepMap[previousStepNameToStepIdMap[stepIdToNameMap[temporaryStepId]]];
            if ((0, steps_1.isTrigger)(step) && previousTriggerStep) {
                step.id = previousTriggerStep.id;
            }
            else if (previousStep && previousStep !== previousTriggerStep) {
                step.id = previousStep.id;
                for (const key of Object.keys(previousStep._migrations ?? {})) {
                    step.setMigration(key, previousStep._migrations?.[key]);
                }
            }
            else {
                step.id = (0, uuid_1.v4)();
                step.setMigration('name', stepIdToNameMap[temporaryStepId]);
            }
            stepIdToNameMap[step.id] = stepIdToNameMap[temporaryStepId];
            tempIdToStepIdMap[temporaryStepId] = step.id;
            const stepDependencies = {
                workflowId: this.id,
                tempIdToStepIdMap,
                events: this.events,
                upStreamStepIds: Object.values(tempIdToStepIdMap),
                inputs,
                sharedInputs: this.sharedInputs,
                inputSources: this.inputSources,
                secrets: this.secrets,
                integrationType: this.integrationType,
                stepIdToNameMap,
                currentStepId: step.id,
                paginationSchemes: this.paginationSchemes,
                customTriggers: this.customTriggers,
                resources: this.resources,
            };
            step.setStepDependencies(stepDependencies);
            if (step.type === steps_1.StepType.MAP) {
                const nextIterationId = step
                    .parameters.nextToIterate;
                const tempIdToStepIdMapForMapPath = {
                    ...tempIdToStepIdMap,
                };
                if (nextIterationId) {
                    traverseSteps(getStepById(nextIterationId), tempIdToStepIdMapForMapPath);
                }
                Object.assign(tempIdToStepIdMap, tempIdToStepIdMapForMapPath);
            }
            else if (step.type === steps_1.StepType.IFELSE) {
                const conditionalStep = step;
                const ifSteId = conditionalStep.parameters.choices.find((choice) => choice.label === 'Yes')?.next;
                const tempIdToStepIdMapForIfPath = {
                    ...tempIdToStepIdMap,
                };
                const tempIdToStepIdMapForElsePath = {
                    ...tempIdToStepIdMap,
                };
                if (ifSteId) {
                    traverseSteps(getStepById(ifSteId), tempIdToStepIdMapForIfPath);
                }
                const elseStepId = conditionalStep.parameters.choices.find((choice) => choice.label === 'No')?.next;
                if (elseStepId) {
                    traverseSteps(getStepById(elseStepId), tempIdToStepIdMapForElsePath);
                }
                Object.assign(tempIdToStepIdMap, {
                    ...tempIdToStepIdMapForIfPath,
                    ...tempIdToStepIdMapForElsePath,
                });
            }
        };
        const traverseSteps = (step, stepDetails) => {
            let currentStep = step;
            while (currentStep) {
                traverseStep(currentStep, stepDetails);
                if (currentStep.next) {
                    currentStep = getStepById(currentStep.next);
                }
                else {
                    currentStep = undefined;
                }
            }
        };
        traverseSteps(triggerStep, stepTempIdToActualIdStore);
        return nameToStepMap;
    }
    reset() {
        while (this.steps.length) {
            this.steps.pop();
        }
    }
    setPreviousStateMachine(stateMachine) {
        this.previousStateMachine = stateMachine;
    }
}
exports.Workflow = Workflow;
//# sourceMappingURL=workflow.js.map