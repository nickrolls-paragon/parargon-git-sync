"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProxyInputString = exports.proxyToSource = exports.createProxyInputReference = exports.getProxySourceType = exports.getInputReferenceFromProxy = exports.getKeysAccessedFromProxy = exports.isProxy = void 0;
const tslib_1 = require("tslib");
const node_util_1 = tslib_1.__importDefault(require("node:util"));
const inputs_1 = require("../inputs");
const secret_1 = require("../secret");
const step_utils_1 = require("../steps/step.utils");
const context_constants_1 = require("./context.constants");
const context_interface_1 = require("./context.interface");
function isProxy(maybeProxy) {
    return node_util_1.default.types.isProxy(maybeProxy);
}
exports.isProxy = isProxy;
function getKeysAccessedFromProxy(proxy) {
    return proxy[context_constants_1.PROXY_KEY_GET_KEYS]();
}
exports.getKeysAccessedFromProxy = getKeysAccessedFromProxy;
function getInputReferenceFromProxy(proxy) {
    return proxy[context_constants_1.PROXY_KEY_GET_INPUT_REFERENCE]();
}
exports.getInputReferenceFromProxy = getInputReferenceFromProxy;
function getProxySourceType(proxy) {
    return proxy[context_constants_1.PROXY_KEY_SOURCE_TYPE]();
}
exports.getProxySourceType = getProxySourceType;
function createProxyInputReference(input, getInputId, sourceType, existingKeys = []) {
    const keys = [...existingKeys];
    let inputToProxy = input;
    if (!input || typeof input !== 'object') {
        inputToProxy = {};
    }
    const proxy = new Proxy(inputToProxy, {
        get(_target, property) {
            if (property === '_isMockFunction') {
                return false;
            }
            else if (typeof property === 'string' &&
                property.startsWith('@@__IMMUTABLE_')) {
                return undefined;
            }
            else if (property === Symbol.toPrimitive) {
                return () => createProxyInputString(sourceType, getInputId(), keys);
            }
            else if (property === context_constants_1.PROXY_KEY_GET_KEYS) {
                return () => [...keys];
            }
            else if (property === context_constants_1.PROXY_KEY_GET_INPUT_REFERENCE) {
                return () => input;
            }
            else if (property === context_constants_1.PROXY_KEY_SOURCE_TYPE) {
                return () => sourceType;
            }
            keys.push(property.toString());
            return proxy;
        },
    });
    return proxy;
}
exports.createProxyInputReference = createProxyInputReference;
function proxyToSource(proxy, dataType, stepDependencies) {
    const sourceType = getProxySourceType(proxy);
    const keys = getKeysAccessedFromProxy(proxy);
    switch (sourceType) {
        case context_interface_1.ProxyVariableSourceType.STEP_REFERENCE:
            const step = getInputReferenceFromProxy(proxy);
            return {
                type: 'VARIABLE',
                stepId: (0, step_utils_1.extractCorrectStepId)(step.id, stepDependencies),
                path: keys,
                dataType,
            };
        case context_interface_1.ProxyVariableSourceType.PERSONA_META_REFERENCE:
            return { type: 'PERSONA_METADATA', path: keys };
        case context_interface_1.ProxyVariableSourceType.PERSONA_ENDUSERID_REFERENCE:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'EXTERNAL_USER_ID',
            };
        case context_interface_1.ProxyVariableSourceType.OAUTH_ACCESS_TOKEN:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'OAUTH_ACCESS_TOKEN',
            };
        case context_interface_1.ProxyVariableSourceType.CONNECT_USER_PROVIDER_DATA:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'EXTERNAL_USER_PROVIDER_DATA',
                dataKey: keys[0],
            };
        case context_interface_1.ProxyVariableSourceType.CONNECT_USER_PROVIDER_ID:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'EXTERNAL_USER_PROVIDER_ID',
            };
        case context_interface_1.ProxyVariableSourceType.WORKFLOW_INPUT_REFERENCE:
            const input = getInputReferenceFromProxy(proxy);
            return (0, inputs_1.fixDataSourceReferencesInInputSource)({
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'WORKFLOW_SETTING',
                path: keys,
                inputId: input.id,
            }, stepDependencies);
        case context_interface_1.ProxyVariableSourceType.SECRET_REFERENCE:
            const secretKey = getInputReferenceFromProxy(proxy);
            return {
                type: 'ENVIRONMENT_SECRET',
                environmentSecretId: (0, secret_1.getSecretIdForKey)(secretKey, stepDependencies),
            };
        case context_interface_1.ProxyVariableSourceType.SAME_STEP_REFERENCE:
            const sameStep = getInputReferenceFromProxy(proxy);
            return {
                type: 'SAME_STEP_REFERENCE',
                name: 'pageToken',
                dataType,
                path: keys,
                stepId: (0, step_utils_1.extractCorrectStepId)(sameStep.id, stepDependencies),
            };
        case context_interface_1.ProxyVariableSourceType.CONNECT_USER_CREDENTIAL_ID:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'EXTERNAL_USER_CREDENTIAL_ID',
            };
        case context_interface_1.ProxyVariableSourceType.CONNECT_USER_CONFIGURATION_ID:
            return {
                type: 'CONNECT_CREDENTIAL_FIELD',
                fieldType: 'EXTERNAL_USER_CONFIGURATION_ID',
            };
        case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_URL:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'CUSTOM_WEBHOOK_TRIGGER_URL',
            };
        case context_interface_1.ProxyVariableSourceType.CREDENTIAL_VALUES:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'CREDENTIAL_VALUES',
                path: keys,
            };
        case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_HANDSHAKE_RESPONSE:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'CUSTOM_WEBHOOK_TRIGGER_HANDSHAKE_RESPONSE',
                path: keys,
            };
        case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_SETUP_RESPONSE:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'CUSTOM_WEBHOOK_TRIGGER_SETUP_RESPONSE',
                path: keys,
            };
        case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_WEBHOOK_RESPONSE:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'CUSTOM_WEBHOOK_TRIGGER_WEBHOOK_RESPONSE',
                path: keys,
            };
        case context_interface_1.ProxyVariableSourceType.PROFILE_CONFIG_KEY:
            return {
                type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                fieldType: 'PROFILE_CONFIG_KEY',
                path: keys,
            };
        default:
            throw new Error(`${sourceType} is not supported.`);
    }
}
exports.proxyToSource = proxyToSource;
function createProxyInputString(sourceType, inputId, keys) {
    return `${context_constants_1.TokenizedIdentifiers.START}${sourceType}${context_constants_1.PROXY_FIELD_SEPARATOR}${inputId}${context_constants_1.PROXY_FIELD_SEPARATOR}${keys.join(context_constants_1.PROXY_KEY_SEPARATOR)}${context_constants_1.TokenizedIdentifiers.END}`;
}
exports.createProxyInputString = createProxyInputString;
//# sourceMappingURL=context.utils.js.map