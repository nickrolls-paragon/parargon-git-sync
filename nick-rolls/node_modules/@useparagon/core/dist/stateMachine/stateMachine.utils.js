"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workflowStepsToStateMachine = exports.sanitizeStateMachine = exports.isStepInFanout = exports.isStepInConditional = exports.getDownstreamSteps = exports.getUpstreamSteps = exports.getStepBefore = exports.traverseStateMachineBySequence = exports.getLastStepInSequence = void 0;
const step_interface_1 = require("../steps/step.interface");
const step_utils_1 = require("../steps/step.utils");
const stateMachine_constants_1 = require("./stateMachine.constants");
const stateMachine_interface_1 = require("./stateMachine.interface");
function getLastStepInSequence(sequence, stateMachine) {
    const nextSequenceEdge = sequence.sequenceEdges.find((edge) => edge.type === 'NEXT');
    const nextSequence = stateMachine.sequenceMap[nextSequenceEdge?.to || ''];
    if (nextSequence && nextSequence.stepIds.length > 0) {
        return getLastStepInSequence(nextSequence, stateMachine);
    }
    return stateMachine.stepMap[sequence.stepIds[sequence.stepIds.length - 1]];
}
exports.getLastStepInSequence = getLastStepInSequence;
function createSequence(withStep, sequences, type) {
    const sequence = {
        id: `sequence-${sequences.length}`,
        start: withStep?.id,
        stepIds: withStep ? [withStep.id] : [],
        stepEdges: [],
        sequenceEdges: [],
        type,
        conditionalBranchWidth: 0,
    };
    sequences.push(sequence);
    return sequence;
}
function traverseSteps(step, sequence, stepMap, sequences, traversed, conditionalBranchWidth = 0) {
    let maxConditionalBranchWidth = conditionalBranchWidth;
    let nextStepId = step?.next ?? null;
    let nextStep = nextStepId
        ? stepMap[nextStepId]
        : undefined;
    let choice;
    let newSequence;
    let newSequenceEdge;
    const newStepEdge = {
        from: step.id,
        to: nextStepId,
    };
    if (traversed.includes(step.id)) {
        return conditionalBranchWidth;
    }
    traversed.push(step.id);
    sequence.stepEdges.push(newStepEdge);
    if (nextStep && !(0, step_utils_1.isConditional)(step) && !(0, step_utils_1.isFanout)(step)) {
        if ((0, step_utils_1.isTrigger)(step)) {
            newSequence = createSequence(nextStep, sequences, stateMachine_interface_1.SequenceType.MAIN);
            sequence.sequenceEdges.push({
                type: stateMachine_interface_1.SequenceEdgeType.NEXT,
                from: sequence.id,
                to: newSequence.id,
            });
            traverseSteps(nextStep, newSequence, stepMap, sequences, traversed);
        }
        else if ((0, step_utils_1.isConditional)(nextStep) || (0, step_utils_1.isFanout)(nextStep)) {
            newSequence = createSequence(nextStep, sequences, sequence.type);
            sequence.sequenceEdges.push({
                type: stateMachine_interface_1.SequenceEdgeType.NEXT,
                from: sequence.id,
                to: newSequence.id,
            });
            conditionalBranchWidth += traverseSteps(nextStep, newSequence, stepMap, sequences, traversed);
        }
        else {
            sequence.stepIds.push(nextStepId);
            conditionalBranchWidth = Math.max(traverseSteps(nextStep, sequence, stepMap, sequences, traversed), conditionalBranchWidth);
        }
    }
    if ((0, step_utils_1.isConditional)(step)) {
        conditionalBranchWidth += 1;
        let i = 0;
        const choices = step?.parameters?.choices || [];
        while (i < choices.length) {
            choice = choices[i];
            nextStepId = choice.next;
            nextStep = nextStepId ? stepMap[nextStepId] : undefined;
            newSequence = createSequence(nextStep, sequences, stateMachine_interface_1.SequenceType.BRANCH);
            newSequenceEdge = {
                type: stateMachine_interface_1.SequenceEdgeType.BRANCH,
                from: sequence.id,
                to: newSequence.id,
            };
            sequence.stepEdges.push({
                label: choice.label,
                from: step.id,
                to: nextStepId,
            });
            sequence.sequenceEdges.push(newSequenceEdge);
            if (nextStep) {
                conditionalBranchWidth += traverseSteps(nextStep, newSequence, stepMap, sequences, traversed);
            }
            i++;
        }
        nextStepId = step.next ?? null;
        nextStep = stepMap[nextStepId || ''];
        newSequence = createSequence(nextStep, sequences, stateMachine_interface_1.SequenceType.MAIN);
        sequence.sequenceEdges.push({
            type: stateMachine_interface_1.SequenceEdgeType.NEXT,
            from: sequence.id,
            to: newSequence.id,
        });
        if (nextStep) {
            maxConditionalBranchWidth = Math.max(traverseSteps(nextStep, newSequence, stepMap, sequences, traversed), conditionalBranchWidth);
        }
        else {
            maxConditionalBranchWidth = Math.max(maxConditionalBranchWidth, conditionalBranchWidth);
        }
        sequence.conditionalBranchWidth = conditionalBranchWidth;
    }
    else if ((0, step_utils_1.isFanout)(step)) {
        sequence.conditionalBranchWidth = 0.5;
        conditionalBranchWidth += 0.5;
        nextStepId = step.parameters.nextToIterate;
        nextStep = stepMap[nextStepId || ''];
        newSequence = createSequence(nextStep, sequences, stateMachine_interface_1.SequenceType.FANOUT);
        sequence.sequenceEdges.push({
            type: stateMachine_interface_1.SequenceEdgeType.FANOUT,
            from: sequence.id,
            to: newSequence.id,
        });
        if (nextStep) {
            sequence.conditionalBranchWidth = Math.max(traverseSteps(nextStep, newSequence, stepMap, sequences, traversed), sequence.conditionalBranchWidth);
        }
        nextStep = stepMap[step.next || ''];
        newSequence = createSequence(nextStep, sequences, stateMachine_interface_1.SequenceType.MAIN);
        sequence.sequenceEdges.push({
            type: stateMachine_interface_1.SequenceEdgeType.NEXT,
            from: sequence.id,
            to: newSequence.id,
        });
        if (nextStep) {
            maxConditionalBranchWidth = Math.max(traverseSteps(nextStep, newSequence, stepMap, sequences, traversed), conditionalBranchWidth);
        }
    }
    return Math.max(maxConditionalBranchWidth, conditionalBranchWidth);
}
function verifyStateMachine(stateMachine) {
    const steps = Object.values(stateMachine.stepMap);
    let message;
    for (const step of steps) {
        if (step.next === step.id) {
            message =
                "StateMachine invalid: step's 'next' property is pointing to itself.";
            throw new Error(message);
        }
        const parentSteps = getUpstreamSteps(step.id, stateMachine);
        for (const parentStep of parentSteps) {
            if (step.next === parentStep.id) {
                message = 'StateMachine invalid: Cyclical workflow detected.';
                throw new Error(message);
            }
        }
    }
}
function traverseStateMachineBySequence(stateMachine, sequenceVisitor, currentSequenceId = stateMachine.start) {
    const currentSequence = stateMachine.sequenceMap[currentSequenceId];
    sequenceVisitor(currentSequence);
    currentSequence.sequenceEdges.forEach(({ to }) => traverseStateMachineBySequence(stateMachine, sequenceVisitor, to));
}
exports.traverseStateMachineBySequence = traverseStateMachineBySequence;
function getStepBefore(stepsOrWorkflow, step, traversed = []) {
    if (!Array.isArray(stepsOrWorkflow)) {
        stepsOrWorkflow = stepsOrWorkflow.steps;
    }
    return stepsOrWorkflow.find((s) => !traversed.filter((t) => t.id === s.id).length &&
        (s.next === step.id ||
            (s.type === step_interface_1.StepType.IFELSE &&
                s.parameters?.choices?.find((choice) => choice.next === step.id)) ||
            (s.type === step_interface_1.StepType.MAP && s.next === step.id) ||
            (s.type === step_interface_1.StepType.MAP && s.parameters.nextToIterate === step.id)));
}
exports.getStepBefore = getStepBefore;
function getUpstreamSteps(stepId, stateMachine) {
    if (!stateMachine.stepMap[stepId]) {
        return [];
    }
    function recurseUp(recurseStartStep) {
        let currentStep = recurseStartStep;
        while (currentStep &&
            currentStep.id !== triggerStep?.id &&
            !(0, step_utils_1.isStepInStepList)(currentStep, upstreamSteps)) {
            if (stepId !== currentStep.id &&
                (0, step_utils_1.isConditional)(currentStep) &&
                !isStepInConditional(initialStep, currentStep, stateMachine)) {
                const downstreamSteps = getDownstreamSteps(currentStep.id, stateMachine, stepId).reverse();
                (0, step_utils_1.concatAndDedupeStepLists)(upstreamSteps, downstreamSteps, false);
            }
            else if (stepId !== currentStep.id &&
                (0, step_utils_1.isFanout)(currentStep) &&
                !isStepInFanout(initialStep, currentStep, stateMachine)) {
                const downstreamSteps = getDownstreamSteps(currentStep.id, stateMachine, stepId).reverse();
                (0, step_utils_1.concatAndDedupeStepLists)(upstreamSteps, downstreamSteps, false);
            }
            upstreamSteps.push(currentStep);
            currentStep = getStepBefore(workflowSteps, stateMachine.stepMap[currentStep.id], upstreamSteps);
        }
    }
    const initialStep = stateMachine.stepMap[stepId];
    const upstreamSteps = [];
    const allSteps = Object.values(stateMachine.stepMap);
    const triggerStep = allSteps.find(step_utils_1.isTrigger);
    const workflowSteps = triggerStep
        ? getDownstreamSteps(triggerStep.id, stateMachine)
        : allSteps;
    recurseUp(initialStep);
    if (triggerStep && !(0, step_utils_1.isStepInStepList)(triggerStep, upstreamSteps)) {
        upstreamSteps.push(triggerStep);
    }
    upstreamSteps.reverse();
    return upstreamSteps.filter((s) => s.id !== stepId);
}
exports.getUpstreamSteps = getUpstreamSteps;
function getDownstreamSteps(stepId, stateMachine, stopId = null) {
    if (!stateMachine.stepMap[stepId]) {
        return [];
    }
    function recurseDown(initialStep) {
        let currentStep = initialStep;
        while (currentStep &&
            !(0, step_utils_1.isStepInStepList)(currentStep, downstreamSteps)) {
            downstreamSteps.push(currentStep);
            if ((0, step_utils_1.isConditional)(currentStep)) {
                const conditionalStep = currentStep;
                const choiceId0 = conditionalStep.parameters?.choices[0].next;
                choiceId0 && recurseDown(stateMachine.stepMap[choiceId0]);
                const choiceId1 = conditionalStep.parameters?.choices[1].next;
                choiceId1 && recurseDown(stateMachine.stepMap[choiceId1]);
            }
            else if ((0, step_utils_1.isFanout)(currentStep)) {
                const nextId = currentStep.parameters.nextToIterate ?? null;
                nextId && recurseDown(stateMachine.stepMap[nextId]);
            }
            currentStep = currentStep.next
                ? stateMachine.stepMap[currentStep.next]
                : undefined;
            if (currentStep && currentStep.id === stopId) {
                break;
            }
        }
    }
    const initialStep = stateMachine.stepMap[stepId];
    const downstreamSteps = [];
    recurseDown(initialStep);
    const filterStepIds = [
        stateMachine.stepMap[stepId],
        ...(stopId ? getDownstreamSteps(stopId, stateMachine) : []),
    ].map((s) => s.id);
    return downstreamSteps.filter((s) => !filterStepIds.includes(s.id));
}
exports.getDownstreamSteps = getDownstreamSteps;
function isStepInConditional(step, conditional, stateMachine) {
    if (step.id === conditional.id) {
        return false;
    }
    const downstreamSteps = getDownstreamSteps(conditional.id, stateMachine, conditional.next);
    const result = downstreamSteps.filter((s) => s.id === step.id).length > 0;
    return result;
}
exports.isStepInConditional = isStepInConditional;
function isStepInFanout(step, mapStep, stateMachine) {
    if (step.id === mapStep.id) {
        return true;
    }
    const downstreamSteps = getDownstreamSteps(mapStep.id, stateMachine, mapStep.next);
    const result = downstreamSteps.filter((s) => s.id === step.id).length > 0;
    return result;
}
exports.isStepInFanout = isStepInFanout;
function sanitizeStateMachine(stateMachine) {
    if (!stateMachine.unusedSteps) {
        stateMachine.unusedSteps = [];
    }
    for (const stepId of stateMachine.unusedSteps) {
        for (const step of Object.values(stateMachine.stepMap)) {
            if (stepId === step.id) {
                delete stateMachine.stepMap[step.id];
            }
        }
    }
    const allSteps = Object.values(stateMachine.stepMap);
    const triggerStep = allSteps.find(step_utils_1.isTrigger);
    const steps = triggerStep
        ? getDownstreamSteps(triggerStep.id, stateMachine)
        : allSteps;
    for (const step of steps) {
        if (step.id === step.next) {
            stateMachine.stepMap[step.id].next = null;
        }
        if (step.next && !stateMachine.stepMap[step.next]) {
            stateMachine.stepMap[step.id].next = null;
        }
        if ((0, step_utils_1.isFanout)(step) &&
            step.parameters.nextToIterate &&
            !stateMachine.stepMap[step.parameters.nextToIterate]) {
            stateMachine.stepMap[step.id].parameters.nextToIterate =
                null;
        }
        if ((0, step_utils_1.isConditional)(step)) {
            let index = -1;
            for (const choice of step.parameters.choices) {
                index += 1;
                if (choice.next && !stateMachine.stepMap[choice.next]) {
                    stateMachine.stepMap[step.id].parameters.choices[index].next = null;
                }
            }
        }
        const parentSteps = getUpstreamSteps(step.id, stateMachine);
        for (const parentStep of parentSteps) {
            if (step.next === parentStep.id && step.id !== parentStep.id) {
                stateMachine.stepMap[step.id].next = null;
            }
        }
        if (step.next === step.id) {
            stateMachine.stepMap[step.id].next = null;
        }
    }
    return stateMachine;
}
exports.sanitizeStateMachine = sanitizeStateMachine;
function workflowStepsToStateMachine(steps, connectConditionalNextSteps = false, startStepId) {
    if (steps.length === 0) {
        return stateMachine_constants_1.EMPTY_STATE_MACHINE;
    }
    const stepMap = {};
    steps.forEach((step) => (stepMap[step.id] = step));
    const sequences = [];
    const traversedSteps = [];
    const triggerStep = steps.find(step_utils_1.isTrigger);
    if (!triggerStep) {
        throw new Error('Trigger step not found');
    }
    createSequence(triggerStep, sequences, stateMachine_interface_1.SequenceType.TRIGGER);
    traverseSteps(triggerStep, sequences[0], stepMap, sequences, traversedSteps);
    const sequenceMap = {};
    sequences.forEach((sequence) => (sequenceMap[sequence.id] = sequence));
    const stateMachine = {
        stepMap,
        sequenceMap,
        start: sequences[0].id,
        activeStepId: startStepId ? startStepId : triggerStep.id,
        finalStepId: startStepId && startStepId !== triggerStep.id ? startStepId : undefined,
        unusedSteps: steps
            .map((step) => step.id)
            .filter((id) => !traversedSteps.includes(id)),
    };
    if (connectConditionalNextSteps) {
        let lastNextFromConditional = null;
        const visitedConditionalIds = [];
        const lastStep = getLastStepInSequence(stateMachine.sequenceMap[stateMachine.start], stateMachine);
        traverseStateMachineBySequence(stateMachine, (sequence) => {
            if (sequence.stepIds.length === 1 &&
                stateMachine.stepMap[sequence.stepIds[0]].type === step_interface_1.StepType.IFELSE) {
                const conditionalStep = stateMachine.stepMap[sequence.stepIds[0]];
                if (visitedConditionalIds.includes(conditionalStep.id)) {
                    return;
                }
                if (!conditionalStep.next &&
                    lastStep?.id !== conditionalStep.id &&
                    conditionalStep.id !== lastNextFromConditional) {
                    conditionalStep.next = lastNextFromConditional;
                }
                lastNextFromConditional = conditionalStep.next;
                const branches = sequence.sequenceEdges.filter((edge) => edge.type === stateMachine_interface_1.SequenceEdgeType.BRANCH);
                branches.forEach(({ to }) => {
                    const lastStep = getLastStepInSequence(stateMachine.sequenceMap[to], stateMachine);
                    if (lastStep && lastStep.id !== conditionalStep.next) {
                        lastStep.next = conditionalStep.next;
                    }
                });
                visitedConditionalIds.push(conditionalStep.id);
            }
        });
    }
    const finalStateMachine = sanitizeStateMachine(stateMachine);
    verifyStateMachine(finalStateMachine);
    return finalStateMachine;
}
exports.workflowStepsToStateMachine = workflowStepsToStateMachine;
//# sourceMappingURL=stateMachine.utils.js.map