/// <reference types="node" />
import { StepDependencies } from '../steps/step.interface';
export declare enum DataType {
    STRING = "STRING",
    NUMBER = "NUMBER",
    DATE = "DATE",
    BOOLEAN = "BOOLEAN",
    EMAIL = "EMAIL",
    OBJECT = "OBJECT",
    ARRAY = "ARRAY",
    ANY = "ANY",
    FILE = "FILE",
    NON_DECIMAL = "NON_DECIMAL"
}
type FileDataType = Buffer;
export type FileValue = {
    data: FileDataType;
    dataType: DataType.FILE;
    encoding?: string;
    id?: string;
    mimeType?: string;
    name?: string;
    size?: string;
};
export type DataTypeValues = {
    STRING: string;
    NUMBER: number;
    DATE: Date;
    BOOLEAN: boolean;
    EMAIL: string;
    OBJECT: Record<string, any>;
    ARRAY: any[];
    ANY: any;
    FILE: FileValue;
    NON_DECIMAL: number;
};
export type ValueSource<T extends DataType = DataType> = {
    dataType?: T;
    type: 'VALUE';
    value: DataTypeValues[T];
};
export declare enum FanInStrategy {
    SINGLE = "SINGLE",
    SINGLE_BY_FANOUT = "SINGLE_BY_FANOUT",
    MULTI = "MULTI",
    MULTI_BY_FANOUT = "MULTI_BY_FANOUT"
}
export type VariableSource<T extends DataType = DataType> = {
    dataType?: T;
    type: 'VARIABLE';
    stepId: string;
    path: string[];
};
export type SecretSource = {
    type: 'ENVIRONMENT_SECRET';
    environmentSecretId: string;
};
export type PersonaMetadataSource = {
    type: 'PERSONA_METADATA';
    path?: string[];
};
export type CustomWebhookTriggerSource = {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_URL';
} | {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_SETUP_RESPONSE';
    path: string[];
} | {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_HANDSHAKE_RESPONSE';
    path: string[];
} | {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_WEBHOOK_RESPONSE';
    path: string[];
} | {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'CREDENTIAL_VALUES';
    path: string[];
} | {
    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD';
    fieldType: 'PROFILE_CONFIG_KEY';
    path: string[];
};
export type ConnectCredentialSource = {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'WORKFLOW_SETTING';
    inputId: string;
    path?: string[];
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'SHARED_WORKFLOW_SETTING';
    inputId: string;
    path?: string[];
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'EXTERNAL_USER_ID';
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'EXTERNAL_USER_PROVIDER_ID';
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'OAUTH_ACCESS_TOKEN';
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'EXTERNAL_USER_PROVIDER_DATA';
    dataKey: string;
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'EXTERNAL_USER_CREDENTIAL_ID';
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'EXTERNAL_USER_CONFIGURATION_ID';
};
export type InputConnectCredentialSource = {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'WORKFLOW_SETTING';
    inputId: string;
    path?: string[] | undefined;
} | {
    type: 'CONNECT_CREDENTIAL_FIELD';
    fieldType: 'SHARED_WORKFLOW_SETTING';
    inputId: string;
    path?: string[] | undefined;
};
export type ConditionSource = {
    type: 'CONDITION';
    condition: ConditionWrapper;
};
export type SameStepReferenceSource<T extends DataType = DataType> = {
    dataType?: T;
    type: 'SAME_STEP_REFERENCE';
    stepId: string;
    path: string[];
    name: string;
};
export type TokenizedValue<T extends DataType = DataType> = ValueSource<T> | VariableSource<T> | SecretSource | ConnectCredentialSource | PersonaMetadataSource | SameStepReferenceSource<T> | CustomWebhookTriggerSource;
export type TokenizedSource<T extends DataType = DataType> = {
    dataType?: T;
    type: 'TOKENIZED';
    parts: TokenizedValue[];
};
export type Source<T extends DataType = DataType> = ValueSource<T> | VariableSource<T> | TokenizedSource<T> | ConditionSource | SecretSource | PersonaMetadataSource | ConnectCredentialSource | SameStepReferenceSource<T> | CustomWebhookTriggerSource;
export type KeyedSource<T extends DataType = DataType> = {
    key: string | Source<T>;
    source: Source<T>;
};
export declare enum Operator {
    'None' = "$none",
    'StringContains' = "$stringContains",
    'StringDoesNotContain' = "$stringDoesNotContain",
    'StringExactlyMatches' = "$stringExactlyMatches",
    'StringDoesNotExactlyMatch' = "$stringDoesNotExactlyMatch",
    'StringIsIn' = "$stringIsIn",
    'StringIsNotIn' = "$stringIsNotIn",
    'StringStartsWith' = "$stringStartsWith",
    'StringDoesNotStartWith' = "$stringDoesNotStartWith",
    'StringEndsWith' = "$stringEndsWith",
    'StringDoesNotEndWith' = "$stringDoesNotEndWith",
    'NumberGreaterThan' = "$numberGreaterThan",
    'NumberLessThan' = "$numberLessThan",
    'NumberEquals' = "$numberEquals",
    'NumberDoesNotEqual' = "$numberDoesNotEqual",
    'NumberLessThanOrEqualTo' = "$numberLessThanOrEqualTo",
    'NumberGreaterThanOrEqualTo' = "$numberGreaterThanOrEqualTo",
    'DateTimeAfter' = "$dateTimeAfter",
    'DateTimeBefore' = "$dateTimeBefore",
    'DateTimeEquals' = "$dateTimeEquals",
    'BooleanTrue' = "$booleanTrue",
    'BooleanFalse' = "$booleanFalse",
    'IsNotNull' = "$exists",
    'IsNull' = "$doesNotExist",
    'Exists' = "$isNotUndefinedOrNull",
    'DoesNotExist' = "$isUndefinedOrNull",
    'ArrayIsIn' = "$arrayIsIn",
    'ArrayIsNotIn' = "$arrayIsNotIn",
    'ArrayIsEmpty' = "$arrayIsEmpty",
    'ArrayIsNotEmpty' = "$arrayIsNotEmpty",
    'StringGreaterThan' = "$stringGreaterThan",
    'StringLessThan' = "$stringLessThan"
}
export type Condition<T extends Operator = never> = Exclude<{
    operator: Operator.None;
    variable: Source<DataType.ANY>;
} | {
    operator: Operator.StringContains;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringDoesNotContain;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringExactlyMatches;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringDoesNotExactlyMatch;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringIsIn;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.ARRAY>;
} | {
    operator: Operator.StringIsNotIn;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.ARRAY>;
} | {
    operator: Operator.StringStartsWith;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringDoesNotStartWith;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringEndsWith;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringDoesNotEndWith;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.NumberGreaterThan;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.NumberLessThan;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.NumberGreaterThanOrEqualTo;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.NumberLessThanOrEqualTo;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.NumberEquals;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.NumberDoesNotEqual;
    variable: Source<DataType.NUMBER>;
    argument: Source<DataType.NUMBER>;
} | {
    operator: Operator.DateTimeAfter;
    variable: Source<DataType.DATE>;
    argument: Source<DataType.DATE>;
} | {
    operator: Operator.DateTimeBefore;
    variable: Source<DataType.DATE>;
    argument: Source<DataType.DATE>;
} | {
    operator: Operator.DateTimeEquals;
    variable: Source<DataType.DATE>;
    argument: Source<DataType.DATE>;
} | {
    operator: Operator.BooleanTrue;
    variable: Source<DataType.BOOLEAN>;
} | {
    operator: Operator.BooleanFalse;
    variable: Source<DataType.BOOLEAN>;
} | {
    operator: Operator.IsNull;
    variable: Source;
} | {
    operator: Operator.IsNotNull;
    variable: Source;
} | {
    operator: Operator.Exists;
    variable: Source;
} | {
    operator: Operator.DoesNotExist;
    variable: Source;
} | {
    operator: Operator.ArrayIsEmpty;
    variable: Source<DataType.ARRAY>;
} | {
    operator: Operator.ArrayIsNotEmpty;
    variable: Source<DataType.ARRAY>;
} | {
    operator: Operator.ArrayIsIn;
    variable: Source<DataType.ARRAY>;
    argument: Source<DataType.ANY>;
} | {
    operator: Operator.ArrayIsNotIn;
    variable: Source<DataType.ARRAY>;
    argument: Source<DataType.ANY>;
} | {
    operator: Operator.StringGreaterThan;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
} | {
    operator: Operator.StringLessThan;
    variable: Source<DataType.STRING>;
    argument: Source<DataType.STRING>;
}, T>;
export type ConditionInit<T extends Operator = never> = (dependencies?: StepDependencies) => Condition<T>;
export type AndConditions = {
    type: 'JOIN';
    join: 'AND';
    conditions: ConditionWrapper[];
};
export type OrConditions = {
    type: 'JOIN';
    join: 'OR';
    conditions: ConditionWrapper[];
};
export type JoinedConditions = AndConditions | OrConditions;
export type OperatorCondition = {
    type: 'OPERATOR';
    condition: Condition;
};
export type ConditionWrapper = JoinedConditions | OperatorCondition;
export {};
