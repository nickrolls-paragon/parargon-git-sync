"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveParamsToSources = exports.resolveToTokenizedSource = exports.buildUrlWithParams = exports.resolveToSource = void 0;
const context_constants_1 = require("../execution/context.constants");
const context_interface_1 = require("../execution/context.interface");
const context_utils_1 = require("../execution/context.utils");
const inputs_1 = require("../inputs");
const secret_1 = require("../secret");
const conditional_utils_1 = require("../steps/library/conditional/conditional.utils");
const step_utils_1 = require("../steps/step.utils");
const resolvers_interface_1 = require("./resolvers.interface");
const tokenizedStringToParts = (input) => {
    const parts = [];
    let count = 0;
    input
        .split(/(__TOKENIZED_START__|__TOKENIZED_END__)/)
        .forEach((part) => part === context_constants_1.TokenizedIdentifiers.START
        ? count++
        : part === context_constants_1.TokenizedIdentifiers.END && count > 0
            ? count--
            : count > 0
                ? parts.push(`${context_constants_1.TokenizedIdentifiers.START}${part}${context_constants_1.TokenizedIdentifiers.END}`)
                : part && parts.push(part));
    return parts;
};
const isValidJSON = (maybeJson) => {
    if (!maybeJson ||
        !(typeof maybeJson === 'string' || typeof maybeJson === 'object')) {
        return false;
    }
    else if (typeof maybeJson === 'string') {
        try {
            const parsedJson = JSON.parse(maybeJson);
            if (parsedJson === null) {
                return false;
            }
        }
        catch {
            return false;
        }
    }
    return true;
};
const parseTokenizedPart = (part, dataType, dependencies) => {
    if (part.startsWith(context_constants_1.TokenizedIdentifiers.START)) {
        const sanitizedPart = part
            .replace(context_constants_1.TokenizedIdentifiers.START, '')
            .replace(context_constants_1.TokenizedIdentifiers.END, '');
        const [type, typeId, paths] = sanitizedPart.split(context_constants_1.PROXY_FIELD_SEPARATOR);
        const path = paths.trim() ? paths.split(context_constants_1.PROXY_KEY_SEPARATOR) : [];
        switch (type) {
            case context_interface_1.ProxyVariableSourceType.STEP_REFERENCE:
                return {
                    dataType,
                    type: 'VARIABLE',
                    stepId: (0, step_utils_1.extractCorrectStepId)(typeId, dependencies),
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.SAME_STEP_REFERENCE:
                return {
                    dataType,
                    type: 'SAME_STEP_REFERENCE',
                    name: 'pageToken',
                    stepId: (0, step_utils_1.extractCorrectStepId)(typeId, dependencies),
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.PERSONA_META_REFERENCE:
                return {
                    type: 'PERSONA_METADATA',
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.PERSONA_ENDUSERID_REFERENCE:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'EXTERNAL_USER_ID',
                };
            case context_interface_1.ProxyVariableSourceType.OAUTH_ACCESS_TOKEN:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'OAUTH_ACCESS_TOKEN',
                };
            case context_interface_1.ProxyVariableSourceType.CONNECT_USER_PROVIDER_DATA:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'EXTERNAL_USER_PROVIDER_DATA',
                    dataKey: path[0],
                };
            case context_interface_1.ProxyVariableSourceType.CONNECT_USER_PROVIDER_ID:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'EXTERNAL_USER_PROVIDER_ID',
                };
            case context_interface_1.ProxyVariableSourceType.CONNECT_USER_CREDENTIAL_ID:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'EXTERNAL_USER_CREDENTIAL_ID',
                };
            case context_interface_1.ProxyVariableSourceType.CONNECT_USER_CONFIGURATION_ID:
                return {
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'EXTERNAL_USER_CONFIGURATION_ID',
                };
            case context_interface_1.ProxyVariableSourceType.WORKFLOW_INPUT_REFERENCE:
                return (0, inputs_1.fixDataSourceReferencesInInputSource)({
                    type: 'CONNECT_CREDENTIAL_FIELD',
                    fieldType: 'WORKFLOW_SETTING',
                    path,
                    inputId: typeId,
                }, dependencies);
            case context_interface_1.ProxyVariableSourceType.SECRET_REFERENCE:
                return {
                    type: 'ENVIRONMENT_SECRET',
                    environmentSecretId: (0, secret_1.getSecretIdForKey)(typeId, dependencies),
                };
            case context_interface_1.ProxyVariableSourceType.CREDENTIAL_VALUES:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'CREDENTIAL_VALUES',
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_URL:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_URL',
                };
            case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_HANDSHAKE_RESPONSE:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_HANDSHAKE_RESPONSE',
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_SETUP_RESPONSE:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_SETUP_RESPONSE',
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.CUSTOM_WEBHOOK_TRIGGER_WEBHOOK_RESPONSE:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'CUSTOM_WEBHOOK_TRIGGER_WEBHOOK_RESPONSE',
                    path,
                };
            case context_interface_1.ProxyVariableSourceType.PROFILE_CONFIG_KEY:
                return {
                    type: 'CUSTOM_WEBHOOK_TRIGGER_INPUT_FIELD',
                    fieldType: 'PROFILE_CONFIG_KEY',
                    path,
                };
            default:
                throw new Error('Invalid tokenized string passed');
        }
    }
    else {
        let dataType = resolvers_interface_1.DataType.STRING;
        if (isValidJSON(part)) {
            dataType = resolvers_interface_1.DataType.OBJECT;
        }
        return {
            dataType,
            type: 'VALUE',
            value: part,
        };
    }
};
const convertPartsToTokenizedValues = (parts, dataType, dependencies) => {
    return parts.map((part) => parseTokenizedPart(part, dataType, dependencies));
};
const resolveToSource = (value, dataType, dependencies) => {
    if ((0, context_utils_1.isProxy)(value)) {
        return (0, context_utils_1.proxyToSource)(value, dataType, dependencies);
    }
    else if (typeof value === 'number' || typeof value === 'boolean') {
        return {
            dataType,
            type: 'VALUE',
            value: value,
        };
    }
    else if (typeof value === 'string' &&
        (value.includes(context_constants_1.TokenizedIdentifiers.START) ||
            value.includes('{{settings.oauthAccessToken}}') ||
            value.includes('{{settings.ClientID}}') ||
            value.includes('{{settings.ClientSecret}}'))) {
        let sanitizedValue = value;
        if (sanitizedValue.includes('{{settings.oauthAccessToken}}')) {
            sanitizedValue = sanitizedValue.replaceAll('{{settings.oauthAccessToken}}', (0, context_utils_1.createProxyInputString)(context_interface_1.ProxyVariableSourceType.OAUTH_ACCESS_TOKEN, '', []));
        }
        if (sanitizedValue.includes('{{settings.ClientID}}')) {
            sanitizedValue = sanitizedValue.replaceAll('{{settings.ClientID}}', (0, context_utils_1.createProxyInputString)(context_interface_1.ProxyVariableSourceType.WORKFLOW_INPUT_REFERENCE, 'clientId', []));
        }
        if (sanitizedValue.includes('{{settings.ClientSecret}}')) {
            sanitizedValue = sanitizedValue.replaceAll('{{settings.ClientSecret}}', (0, context_utils_1.createProxyInputString)(context_interface_1.ProxyVariableSourceType.WORKFLOW_INPUT_REFERENCE, 'clientSecret', []));
        }
        const parts = tokenizedStringToParts(sanitizedValue);
        const tokenizedValues = convertPartsToTokenizedValues(parts, dataType, dependencies);
        return {
            dataType,
            type: 'TOKENIZED',
            parts: tokenizedValues,
        };
    }
    else if ((0, conditional_utils_1.isConditionalInput)(value)) {
        return {
            type: 'CONDITION',
            condition: (0, conditional_utils_1.parseConditionInput)(value, dependencies),
        };
    }
    else if (value && (Array.isArray(value) || typeof value === 'object')) {
        const stringifiedValue = JSON.stringify(value);
        return (0, exports.resolveToSource)(stringifiedValue, dataType, dependencies);
    }
    return {
        type: 'VALUE',
        value: value,
        dataType,
    };
};
exports.resolveToSource = resolveToSource;
const buildUrlWithParams = (url, params) => {
    const baseUrl = url.split('?')[0];
    const queryString = params
        ? Object.entries(params)
            .filter(([key, _]) => typeof key === 'string' && key.trim() !== '')
            .map(([key, value]) => `${key}=${value}`)
            .join('&')
        : '';
    return queryString ? `${baseUrl}?${queryString}` : baseUrl;
};
exports.buildUrlWithParams = buildUrlWithParams;
const resolveToTokenizedSource = (value, dataType, dependencies) => {
    const source = (0, exports.resolveToSource)(value, dataType, dependencies);
    if (source.type === 'TOKENIZED') {
        return source;
    }
    return {
        type: 'TOKENIZED',
        dataType,
        parts: [source],
    };
};
exports.resolveToTokenizedSource = resolveToTokenizedSource;
const resolveParamsToSources = (param, dataType = resolvers_interface_1.DataType.ANY, resolveToTokenized = false, dependencies) => {
    const paramsWithSources = Object.keys(param).reduce((sources, key) => {
        const value = param[key];
        const keyedSource = {
            key: key.includes(context_constants_1.TokenizedIdentifiers.START)
                ? (0, exports.resolveToTokenizedSource)(key, dataType, dependencies)
                : key,
            source: resolveToTokenized
                ? (0, exports.resolveToTokenizedSource)(value, dataType, dependencies)
                : (0, exports.resolveToSource)(value, dataType, dependencies),
        };
        return [...sources, keyedSource];
    }, []);
    return paramsWithSources;
};
exports.resolveParamsToSources = resolveParamsToSources;
//# sourceMappingURL=resolver.utils.js.map