import { DataType, OrConditions, TokenizedSource } from '../../../resolvers/resolvers.interface';
import { IResourceInit } from '../../../resource';
import { Constructable } from '../../../types';
import { IBaseStep, IBaseStepInit, IStepInitIgnoreFailureParameters, IStepInitRetryParameters, StepType } from '../../step.interface-base';
import { ConditionalInput } from '../conditional/conditional.interface';
import { HttpMethodWithBody, HttpMethodWithoutBody, IRequestStepParameters } from '../request/request.interface';
export type IIntegrationRequestStepOutput = {
    response: {
        body: any;
        headers: Record<string, any>;
        statusCode: number;
        error?: any;
    };
};
export declare enum REQUEST_PAGINATION_STRATEGY {
    Token = "TOKEN",
    Range = "Range",
    NextPageToken = "NextPageToken"
}
export type TokenPaginationOptions = {
    type: REQUEST_PAGINATION_STRATEGY.Token;
    output?: TokenizedSource<DataType.STRING | DataType.ANY>;
    pageToken?: TokenizedSource<DataType.STRING>;
    stopCondition?: OrConditions;
};
export type RangePaginationOptions = {
    type: REQUEST_PAGINATION_STRATEGY.Range;
    limit?: TokenizedSource<DataType.STRING | DataType.ANY>;
    skip?: TokenizedSource<DataType.STRING | DataType.ANY>;
};
export type NextPageTokenOptions = {
    type: REQUEST_PAGINATION_STRATEGY.NextPageToken;
    limit?: TokenizedSource<DataType.STRING | DataType.ANY>;
    nextPageToken?: TokenizedSource<DataType.STRING | DataType.ANY>;
};
export type IIntegrationRequestStepInit<Output extends IIntegrationRequestStepOutput = IIntegrationRequestStepOutput, _PaginationScheme extends REQUEST_PAGINATION_STRATEGY[] = [
    REQUEST_PAGINATION_STRATEGY.Token
]> = IBaseStepInit & IStepInitIgnoreFailureParameters & IStepInitRetryParameters & {
    resource?: Constructable<IResourceInit>;
    url: string | ((pageToken: string) => string);
    params?: Record<string, string | ((pageToken: string) => string)>;
    headers?: Record<string, string | ((pageToken: string) => string)>;
    pagination?: ((currentStepOutput: {
        output: Output;
    }) => {
        stopCondition: ConditionalInput;
        outputPath: string;
        pageToken: string;
    }) | {
        type: `${REQUEST_PAGINATION_STRATEGY.Range}`;
        limit?: string;
        skip?: string;
    } | {
        type: `${REQUEST_PAGINATION_STRATEGY.NextPageToken}`;
        limit?: string;
        nextPageToken?: string;
    };
} & ({
    method: `${HttpMethodWithoutBody}`;
    body?: never;
    bodyType?: never;
} | {
    method: `${HttpMethodWithBody}`;
    bodyType: 'json' | 'form-data' | 'x-www-form-urlencoded';
    body: Record<string, unknown | ((pageToken: string) => Record<string, unknown>)>;
} | {
    method: `${HttpMethodWithBody}`;
    bodyType: 'xml' | 'raw';
    body?: string | ((pageToken: string) => string);
});
export type PaginationOptions = {
    enabled: boolean;
} & (RangePaginationOptions | NextPageTokenOptions | TokenPaginationOptions);
export interface IIntegrationRequestStepParameters extends IRequestStepParameters {
    paginationOptions?: PaginationOptions;
    actionType: string;
    resourceId?: string;
}
export interface IIntegrationRequestStep extends IBaseStep {
    type: StepType.CUSTOM_INTEGRATION_REQUEST;
    parameters: IIntegrationRequestStepParameters;
}
