"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FanOutStep = void 0;
const execution_1 = require("../../../execution");
const context_utils_1 = require("../../../execution/context.utils");
const resolver_utils_1 = require("../../../resolvers/resolver.utils");
const resolvers_interface_1 = require("../../../resolvers/resolvers.interface");
const step_1 = require("../../step");
const step_interface_1 = require("../../step.interface");
const step_utils_1 = require("../../step.utils");
class FanOutStep extends step_1.Step {
    type = step_interface_1.StepType.MAP;
    parameters;
    get output() {
        return (0, context_utils_1.createProxyInputReference)(this, () => this.id, execution_1.ProxyVariableSourceType.STEP_REFERENCE);
    }
    _parameters;
    _nextToIterate = undefined;
    constructor(params) {
        super(params);
        this._parameters = params;
        this._parameters.iterator = params.iterator;
        this.parameters = this.serializeParameters();
    }
    branch(step) {
        if (this._nextToIterate) {
            throw new Error('Branch path for fanout step already added.');
        }
        else if ((0, step_utils_1.isTrigger)(step)) {
            throw new Error('Trigger Step can only be first step in step chain.');
        }
        this._nextToIterate = step.getStartingStepInChain();
        this.parameters.nextToIterate = this._nextToIterate.id;
        return this;
    }
    serializeParameters() {
        const iterator = this._parameters.iterator;
        return {
            iterator: (0, resolver_utils_1.resolveToSource)(iterator, resolvers_interface_1.DataType.ARRAY, this.dependencies),
            nextToIterate: this._nextToIterate?.id,
        };
    }
}
exports.FanOutStep = FanOutStep;
//# sourceMappingURL=fanout.step.js.map