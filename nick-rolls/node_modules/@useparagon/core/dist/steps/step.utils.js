"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractCorrectStepId = exports.traverseSteps = exports.mapStepIdToVariableName = exports.concatAndDedupeStepLists = exports.isStepInStepList = exports.stepMapToArray = exports.stepArrayToMap = exports.isFanout = exports.isConditional = exports.getTriggerStep = exports.isTrigger = void 0;
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const step_interface_1 = require("./step.interface");
function isTrigger(step) {
    return step_interface_1.TRIGGER_TYPES.includes(step.type);
}
exports.isTrigger = isTrigger;
function getTriggerStep(steps) {
    return steps.find(isTrigger);
}
exports.getTriggerStep = getTriggerStep;
function isConditional(step) {
    return step.type === step_interface_1.StepType.IFELSE;
}
exports.isConditional = isConditional;
function isFanout(step) {
    return step.type === step_interface_1.StepType.MAP;
}
exports.isFanout = isFanout;
function stepArrayToMap(steps) {
    const stepMap = {};
    steps.forEach((step) => (stepMap[step.id] = step));
    return stepMap;
}
exports.stepArrayToMap = stepArrayToMap;
function stepMapToArray(stepMap) {
    return Object.keys(stepMap).map((stepId) => stepMap[stepId]);
}
exports.stepMapToArray = stepMapToArray;
function isStepInStepList(step, stepList) {
    return step && stepList.filter((s) => s.id === step.id).length > 0
        ? true
        : false;
}
exports.isStepInStepList = isStepInStepList;
function concatAndDedupeStepLists(a, b, createNewArray) {
    const c = createNewArray ? [...a] : a;
    for (const step of b) {
        if (c.filter((s) => s.id === step.id).length === 0) {
            c.push(step);
        }
    }
    return c;
}
exports.concatAndDedupeStepLists = concatAndDedupeStepLists;
function mapStepIdToVariableName(steps) {
    const stepIdToVariableMap = {};
    const variableNameSet = new Set();
    traverseSteps(steps, (currentStep) => {
        if (isTrigger(currentStep)) {
            const variableName = 'triggerStep';
            stepIdToVariableMap[currentStep.id] = variableName;
            variableNameSet.add(stepIdToVariableMap[currentStep.id]);
            return;
        }
        let variableName = currentStep._migrations?.['name'];
        const hasUserSpecifiedName = Boolean(variableName);
        if (!variableName &&
            currentStep.description &&
            currentStep.description.length < 15 &&
            currentStep.description !== 'description') {
            variableName = currentStep.description.toLowerCase();
            while (variableName && !variableName.match(/^[a-zA-Z_$]/)) {
                variableName = variableName.slice(1);
            }
            variableName = (0, utils_1.sanitizeVariableName)(variableName);
        }
        if (!variableName) {
            if (currentStep.type === step_interface_1.StepType.ACTION) {
                variableName = 'action';
            }
            else if (currentStep.type === step_interface_1.StepType.CUSTOM_INTEGRATION_REQUEST) {
                variableName = 'integrationRequest';
            }
            else {
                variableName = (0, utils_1.toCamelCase)(currentStep.type.toLowerCase().split('/')[1].split('_').join(' '));
            }
        }
        const sanitizedName = hasUserSpecifiedName
            ? variableName
            : `${variableName}Step`;
        let count = 0;
        while (variableNameSet.has(`${sanitizedName}${count > 0 ? count : ''}`)) {
            count += 1;
        }
        stepIdToVariableMap[currentStep.id] = `${sanitizedName}${count > 0 ? count : ''}`;
        variableNameSet.add(stepIdToVariableMap[currentStep.id]);
    });
    return stepIdToVariableMap;
}
exports.mapStepIdToVariableName = mapStepIdToVariableName;
function traverseSteps(steps, onTraverse) {
    const triggerStep = steps.find(isTrigger);
    if (!triggerStep) {
        throw new Error('Trigger step not found.');
    }
    const idToStepMap = (0, utils_1.indexBy)('id', steps);
    const traverseStepChain = (triggerStep) => {
        let currentStep = triggerStep;
        while (currentStep) {
            onTraverse(currentStep);
            if (currentStep.type === step_interface_1.StepType.MAP) {
                const nextStepId = currentStep.parameters.nextToIterate;
                if (nextStepId && !idToStepMap[nextStepId]) {
                    throw new Error('Step not found.');
                }
                if (nextStepId) {
                    traverseStepChain(idToStepMap[nextStepId]);
                }
            }
            else if (currentStep.type === step_interface_1.StepType.IFELSE) {
                const conditionalStep = currentStep;
                const ifStepId = conditionalStep.parameters.choices.find((choice) => choice.label === 'Yes')?.next;
                if (ifStepId && !idToStepMap[ifStepId]) {
                    throw new Error('Step not found.');
                }
                if (ifStepId) {
                    traverseStepChain(idToStepMap[ifStepId]);
                }
                const elseStepId = conditionalStep.parameters.choices.find((choice) => choice.label === 'No')?.next;
                if (elseStepId && !idToStepMap[elseStepId]) {
                    throw new Error('Step not found.');
                }
                if (elseStepId) {
                    traverseStepChain(idToStepMap[elseStepId]);
                }
            }
            if (currentStep.next) {
                currentStep = idToStepMap[currentStep.next];
            }
            else {
                currentStep = undefined;
            }
        }
    };
    traverseStepChain(triggerStep);
}
exports.traverseSteps = traverseSteps;
const extractCorrectStepId = (stepId, dependencies) => {
    if (!dependencies?.tempIdToStepIdMap ||
        !dependencies.upStreamStepIds ||
        !dependencies.stepIdToNameMap ||
        !dependencies.currentStepId) {
        return stepId;
    }
    const actualStepId = dependencies.tempIdToStepIdMap[stepId] || stepId;
    if (!dependencies.upStreamStepIds.includes(actualStepId)) {
        const referredStepId = actualStepId;
        const referredStepName = dependencies.stepIdToNameMap[referredStepId] ||
            dependencies.stepIdToNameMap[stepId];
        const currentStepId = dependencies.currentStepId;
        const currentStepName = dependencies.stepIdToNameMap[currentStepId];
        throw new errors_1.DownStreamStepReferenceError({
            referredStepId,
            referredStepName,
            currentStepId,
            currentStepName,
        });
    }
    return actualStepId;
};
exports.extractCorrectStepId = extractCorrectStepId;
//# sourceMappingURL=step.utils.js.map