"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Step = void 0;
const utils_1 = require("../utils");
const step_constants_1 = require("./step.constants");
const step_utils_1 = require("./step.utils");
class Step {
    id = `${step_constants_1.UNSET_STEP_ID}${(0, utils_1.getRandomNumberInRange)(10000, 99999)}`;
    _next;
    description;
    _prevStep;
    _migrations = {};
    dependencies = {};
    get next() {
        return this._next?.id ?? null;
    }
    constructor(params) {
        this.description = params?.description;
    }
    setMigration(key, value) {
        this._migrations[key] = value;
    }
    nextStep(step) {
        if (step._prevStep) {
            throw new Error('This step is already chained.');
        }
        else if ((0, step_utils_1.isTrigger)(step)) {
            throw new Error('Trigger Step can only be first step in step chain.');
        }
        step._prevStep = this;
        this._next = step;
        return step;
    }
    serializeParameters() {
        return this.parameters;
    }
    getStartingStepInChain() {
        let step = this;
        while (step._prevStep) {
            step = step._prevStep;
        }
        return step;
    }
    setStepDependencies(dependencies) {
        for (const [key, value] of Object.entries(dependencies)) {
            this.dependencies[key] = value;
        }
    }
    toObject() {
        const step = {
            id: this.id,
            type: this.type,
            parameters: this.serializeParameters(),
            next: this._next?.id ?? null,
            _migrations: this._migrations,
            description: this.description ?? 'description',
        };
        return step;
    }
    toString() {
        return JSON.stringify(this.toObject());
    }
}
exports.Step = Step;
//# sourceMappingURL=step.js.map